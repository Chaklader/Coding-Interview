# **C-10: Prefix Sum Algorithms and Cumulative Data Structures**

1. **Mathematical Foundations of Prefix Sum Theory**
    - Cumulative Sum Mathematical Properties and Invariants
    - Linear Time Construction Algorithms and Space Complexity
    - Applications in Range Query Processing and Optimization
    - Relationship to Integral Calculus and Discrete Mathematics
2. **Range Query Optimization Through Preprocessing**
    - Constant-Time Range Sum Retrieval Mechanisms
    - Index-Based Formula Derivation and Mathematical Proofs
    - Edge Case Analysis for Boundary Conditions
    - Implementation Patterns and Space-Time Trade-offs
3. **Subarray Analysis and Hash Map Integration**
    - K-Sum Subarray Detection Through Complementary Search
    - Hash Map Frequency Tracking for Multiple Occurrences
    - Optimization from O(n²) to O(n) Time Complexity
    - Mathematical Foundation of Prefix Sum Complement Theory
4. **Prefix Product Algorithms and Division-Free Computation**
    - Left and Right Product Array Construction Methods
    - Space Optimization Through In-Place Computation
    - Avoiding Division Operations Through Multiplicative Decomposition
    - Two-Pass Algorithm Design and Implementation Analysis

#### Mathematical Foundations of Prefix Sum Theory

The prefix sum technique represents one of the most elegant and powerful preprocessing strategies in algorithmic design,
transforming complex range query problems into simple arithmetic operations. At its core, the prefix sum approach builds
upon the mathematical principle of cumulative aggregation, where we precompute partial results to enable efficient
retrieval of arbitrary range sums.

Let me guide you through understanding this fundamental concept by starting with a concrete example from the PDF.
Imagine you're tracking your daily spending on takeout meals throughout a week, and you want to quickly determine how
much you've spent up to any particular day. The spending array might look like this: `[10, 15, 20, 10, 5]` representing
Monday through Friday.

##### Cumulative Sum Mathematical Properties and Invariants

The mathematical foundation of prefix sums rests on the **cumulative aggregation property**, which states that for any
array `nums`, the prefix sum at position `i` equals the sum of all elements from index `0` to index `i`. Formally, if we
define `prefix_sum[i]` as the prefix sum at position `i`, then:

```
prefix_sum[i] = nums[0] + nums[1] + ... + nums[i] = Σ(nums[k]) for k=0 to i
```

This relationship establishes a crucial **invariant**: each prefix sum contains all the information needed to compute
any range sum ending at that position. The mathematical elegance emerges when we realize that to compute
`prefix_sum[i]`, we only need the previous prefix sum and the current element:
`prefix_sum[i] = prefix_sum[i-1] + nums[i]`.

Let's trace through the exact example from your PDF material to see how this works in practice:

```python
def compute_prefix_sums(nums):
    """
    Build prefix sum array exactly as shown in the PDF example.
    This function demonstrates the step-by-step construction process.
    """
    # Start by adding the first number to the prefix sums array
    prefix_sum = [nums[0]]

    # For all remaining indexes, add 'nums[i]' to the cumulative sum
    # from the previous index
    for i in range(1, len(nums)):
        prefix_sum.append(prefix_sum[-1] + nums[i])

    return prefix_sum

# Using the exact example from the PDF
spendings = [10, 15, 20, 10, 5]
prefix_sums = compute_prefix_sums(spendings)
print(f"Original spending: {spendings}")
print(f"Prefix sums: {prefix_sums}")  # Output: [10, 25, 45, 55, 60]
```

The mathematical invariant here ensures that `prefix_sums[i]` always represents the total spending from Monday through
day `i+1`. This property becomes the foundation for all subsequent optimizations and applications.

**Java Implementation with Mathematical Validation:**

```java
import java.util.*;

public class PrefixSumFoundations {

    /**
     * Constructs prefix sum array following the exact algorithm from the PDF.
     * Demonstrates the mathematical progression of cumulative sums.
     */
    public static List<Integer> computePrefixSums(int[] nums) {
        if (nums.length == 0) {
            return new ArrayList<>();
        }

        List<Integer> prefixSum = new ArrayList<>();
        // Start by adding the first number to the prefix sums array
        prefixSum.add(nums[0]);

        // For all remaining indexes, add 'nums[i]' to the cumulative sum
        // from the previous index
        for (int i = 1; i < nums.length; i++) {
            int cumulativeSum = prefixSum.get(prefixSum.size() - 1) + nums[i];
            prefixSum.add(cumulativeSum);
        }

        return prefixSum;
    }

    /**
     * Validates the mathematical invariant of prefix sums.
     * Each prefix_sum[i] should equal the sum of nums[0] through nums[i].
     */
    public static boolean validatePrefixSumInvariant(int[] nums, List<Integer> prefixSums) {
        if (nums.length != prefixSums.size()) {
            return false;
        }

        int runningSum = 0;
        for (int i = 0; i < nums.length; i++) {
            runningSum += nums[i];
            if (runningSum != prefixSums.get(i)) {
                System.out.printf("Invariant violation at index %d: expected %d, got %d%n",
                                i, runningSum, prefixSums.get(i));
                return false;
            }
        }
        return true;
    }

    public static void demonstrateFoundations() {
        // Using the exact spending example from the PDF
        int[] spendings = {10, 15, 20, 10, 5};
        List<Integer> prefixSums = computePrefixSums(spendings);

        System.out.println("=== Prefix Sum Mathematical Foundations ===");
        System.out.println("Original spending: " + Arrays.toString(spendings));
        System.out.println("Prefix sums: " + prefixSums);

        // Validate mathematical invariant
        boolean isValid = validatePrefixSumInvariant(spendings, prefixSums);
        System.out.println("Mathematical invariant satisfied: " + isValid);

        // Show the cumulative property step by step
        System.out.println("\nStep-by-step cumulative construction:");
        int cumulative = 0;
        for (int i = 0; i < spendings.length; i++) {
            cumulative += spendings[i];
            System.out.printf("Day %d: %d + %d = %d%n",
                            i + 1, cumulative - spendings[i], spendings[i], cumulative);
        }
    }
}
```

**C++ Implementation with Mathematical Rigor:**

```cpp
#include <vector>
#include <iostream>
#include <numeric>
#include <cassert>

class PrefixSumFoundations {
public:
    /**
     * Computes prefix sums following the exact mathematical definition.
     * Each element represents the cumulative sum from index 0 to current index.
     */
    static std::vector<int> computePrefixSums(const std::vector<int>& nums) {
        if (nums.empty()) {
            return {};
        }

        std::vector<int> prefixSum;
        prefixSum.reserve(nums.size());  // Optimize memory allocation

        // Start by adding the first number to the prefix sums array
        prefixSum.push_back(nums[0]);

        // For all remaining indexes, add 'nums[i]' to the cumulative sum
        // from the previous index
        for (size_t i = 1; i < nums.size(); ++i) {
            prefixSum.push_back(prefixSum.back() + nums[i]);
        }

        return prefixSum;
    }

    /**
     * Validates that each prefix sum equals the mathematical expectation.
     * This ensures the cumulative property is maintained correctly.
     */
    static bool validateMathematicalProperties(const std::vector<int>& nums,
                                             const std::vector<int>& prefixSums) {
        if (nums.size() != prefixSums.size()) {
            return false;
        }

        // Check cumulative property: prefix_sum[i] = sum(nums[0..i])
        int expectedSum = 0;
        for (size_t i = 0; i < nums.size(); ++i) {
            expectedSum += nums[i];
            if (expectedSum != prefixSums[i]) {
                std::cout << "Mathematical property violated at index " << i
                         << ": expected " << expectedSum
                         << ", got " << prefixSums[i] << std::endl;
                return false;
            }
        }

        // Check incremental property: prefix_sum[i] = prefix_sum[i-1] + nums[i]
        for (size_t i = 1; i < nums.size(); ++i) {
            if (prefixSums[i] != prefixSums[i-1] + nums[i]) {
                std::cout << "Incremental property violated at index " << i << std::endl;
                return false;
            }
        }

        return true;
    }

    /**
     * Demonstrates the mathematical progression of prefix sum construction.
     */
    static void demonstrateMathematicalFoundations() {
        // Use the exact example from the PDF
        std::vector<int> spendings = {10, 15, 20, 10, 5};
        auto prefixSums = computePrefixSums(spendings);

        std::cout << "=== Mathematical Foundations Demonstration ===" << std::endl;
        std::cout << "Original array: ";
        for (int val : spendings) std::cout << val << " ";
        std::cout << std::endl;

        std::cout << "Prefix sums: ";
        for (int val : prefixSums) std::cout << val << " ";
        std::cout << std::endl;

        // Validate mathematical properties
        bool isValid = validateMathematicalProperties(spendings, prefixSums);
        std::cout << "Mathematical properties validated: " << std::boolalpha << isValid << std::endl;

        // Show the mathematical progression
        std::cout << "\nMathematical progression:" << std::endl;
        int cumulative = 0;
        for (size_t i = 0; i < spendings.size(); ++i) {
            int previous = cumulative;
            cumulative += spendings[i];
            std::cout << "prefix_sum[" << i << "] = " << previous
                     << " + " << spendings[i] << " = " << cumulative << std::endl;
        }
    }
};
```

##### Linear Time Construction Algorithms and Space Complexity

The construction of prefix sum arrays achieves optimal linear time complexity through a single pass algorithm that
builds upon the mathematical properties we just established. As demonstrated in the PDF example, building a prefix sum
array takes $O(n)$ time and $O(n)$ space, where $n$ denotes the length of the input array.

The **linear time guarantee** emerges from the fact that each element is processed exactly once, and each prefix sum
computation requires only constant time operations (one addition and one array access). This represents the theoretical
minimum for any algorithm that must examine every input element and produce a complete prefix sum array.

The **space complexity analysis** reveals that we need $O(n)$ additional space to store the prefix sum array. However,
this space investment pays dividends through the constant-time range queries it enables, as we'll explore in the next
section.

Let me show you how this optimal construction works by walking through the exact step-by-step process shown in your PDF
material:

```python
def demonstrate_linear_construction():
    """
    Demonstrates the linear time construction exactly as shown in the PDF.
    Each step shows how we build upon the previous prefix sum.
    """
    nums = [10, 15, 20, 10, 5]
    print("Step-by-step linear construction:")
    print(f"Input array: {nums}")

    # Step 1: Initialize with first element
    prefix_sums = [nums[0]]
    print(f"Step 1: prefix_sums = {prefix_sums}")

    # Step 2: Add second element to previous sum
    prefix_sums.append(prefix_sums[-1] + nums[1])
    print(f"Step 2: prefix_sums = {prefix_sums}")

    # Step 3: Add third element to previous sum
    prefix_sums.append(prefix_sums[-1] + nums[2])
    print(f"Step 3: prefix_sums = {prefix_sums}")

    # Step 4: Add fourth element to previous sum
    prefix_sums.append(prefix_sums[-1] + nums[3])
    print(f"Step 4: prefix_sums = {prefix_sums}")

    # Step 5: Add fifth element to previous sum
    prefix_sums.append(prefix_sums[-1] + nums[4])
    print(f"Step 5: prefix_sums = {prefix_sums}")

    print(f"Final result: {prefix_sums}")
    return prefix_sums

# Run the demonstration
demonstrate_linear_construction()
```

This step-by-step approach reveals how each new prefix sum builds incrementally on the previous one, ensuring linear
time complexity while maintaining mathematical correctness.

##### Applications in Range Query Processing and Optimization

The power of prefix sums becomes apparent when we consider their applications in range query processing. As your PDF
material explains, prefix sums are commonly used to efficiently determine the sum of subarrays, transforming what would
otherwise be $O(n)$ operations into constant time queries.

The mathematical foundation for this optimization lies in the **range sum formula**: for any range $[i, j]$, the sum can
be computed as `prefix_sum[j] - prefix_sum[i-1]` (with special handling when $i = 0$). This formula leverages the
cumulative property of prefix sums to eliminate redundant computation.

Consider the practical application mentioned in your PDF: a company analyzing daily revenue over a month. With prefix
sums, the company can instantly determine revenue for any date range without summing individual daily values. This
represents a fundamental algorithmic optimization that transforms linear-time operations into constant-time queries
through preprocessing.

##### Relationship to Integral Calculus and Discrete Mathematics

The prefix sum technique exhibits deep connections to integral calculus and discrete mathematics that illuminate its
theoretical foundations. In calculus, the **Fundamental Theorem of Calculus** establishes the relationship between
derivatives and integrals. Similarly, prefix sums create a discrete analog where the "derivative" operation (taking
differences between consecutive prefix sums) recovers the original array.

Mathematically, if we define $F(x) = \sum_{i=0}^{x} f(i)$ as our prefix sum function, then $F(x) - F(x-1) = f(x)$, which
mirrors the relationship $\frac{d}{dx}\int_a^x f(t)dt = f(x)$ from calculus.

This connection extends to **discrete integration**, where prefix sums serve as the discrete equivalent of indefinite
integrals. Just as integrals enable efficient computation of areas under curves, prefix sums enable efficient
computation of sums over discrete ranges.

The **telescoping series property** provides another mathematical perspective. When computing a range sum using prefix
sums, we're essentially evaluating a telescoping series where intermediate terms cancel out, leaving only the desired
boundary terms.

#### Range Query Optimization Through Preprocessing

The transformation of range sum queries from linear-time operations to constant-time lookups represents one of the most
powerful applications of the prefix sum technique. Let me walk you through the exact approach demonstrated in your PDF
material, using the "Sum Between Range" problem as our foundation.

##### Constant-Time Range Sum Retrieval Mechanisms

The PDF presents a compelling problem: given an integer array, write a function that returns the sum of values between
two indexes. The naive approach would sum elements from index $i$ to index $j$ for each query, requiring $O(n)$ time per
query. However, with prefix sum preprocessing, we can answer any range query in constant time.

Let me show you the exact solution approach from your PDF material:

```python
class SumBetweenRange:
    """
    Implementation following the exact approach from the PDF.
    Demonstrates constant-time range queries through preprocessing.
    """

    def __init__(self, nums):
        """
        Constructor that builds the prefix sum array for constant-time queries.
        Time complexity: O(n) for preprocessing
        Space complexity: O(n) for storing prefix sums
        """
        # Build prefix sum array exactly as shown in the PDF
        self.prefix_sum = [nums[0]]
        for i in range(1, len(nums)):
            self.prefix_sum.append(self.prefix_sum[-1] + nums[i])

    def sum_range(self, i, j):
        """
        Returns sum of elements from index i to j in constant time.
        Uses the mathematical relationship derived in the PDF.
        """
        if i == 0:
            # When i == 0, sum_range(0, j) = prefix_sum[j]
            return self.prefix_sum[j]
        else:
            # When i > 0, sum_range(i, j) = prefix_sum[j] - prefix_sum[i - 1]
            return self.prefix_sum[j] - self.prefix_sum[i - 1]

# Demonstrate with the exact example from the PDF
def demonstrate_range_queries():
    """
    Uses the exact examples from the PDF to show constant-time retrieval.
    """
    nums = [3, -7, 6, 0, -2, 5]
    range_calculator = SumBetweenRange(nums)

    print("=== Range Query Demonstration ===")
    print(f"Original array: {nums}")
    print(f"Prefix sums: {range_calculator.prefix_sum}")

    # Test the exact queries from the PDF
    result1 = range_calculator.sum_range(0, 3)  # Expected: 2
    result2 = range_calculator.sum_range(2, 4)  # Expected: 4
    result3 = range_calculator.sum_range(2, 2)  # Expected: 6

    print(f"sum_range(0, 3) = {result1}")  # 3 + (-7) + 6 + 0 = 2
    print(f"sum_range(2, 4) = {result2}")  # 6 + 0 + (-2) = 4
    print(f"sum_range(2, 2) = {result3}")  # 6 = 6

demonstrate_range_queries()
```

**Java Implementation Following PDF Structure:**

```java
public class SumBetweenRange {
    private int[] prefixSum;

    /**
     * Constructor that preprocessing the array for constant-time queries.
     * Implements the exact algorithm structure from the PDF.
     */
    public SumBetweenRange(int[] nums) {
        // Build prefix sum array following PDF approach
        prefixSum = new int[nums.length];
        prefixSum[0] = nums[0];

        for (int i = 1; i < nums.length; i++) {
            prefixSum[i] = prefixSum[i - 1] + nums[i];
        }
    }

    /**
     * Returns sum of elements from index i to j in O(1) time.
     * Uses the mathematical formulas derived in the PDF.
     */
    public int sumRange(int i, int j) {
        if (i == 0) {
            // When i == 0: sum_range(0, j) = prefix_sum[j]
            return prefixSum[j];
        } else {
            // When i > 0: sum_range(i, j) = prefix_sum[j] - prefix_sum[i - 1]
            return prefixSum[j] - prefixSum[i - 1];
        }
    }

    /**
     * Demonstrates the range query functionality with PDF examples.
     */
    public static void demonstrateRangeQueries() {
        // Use exact example from PDF
        int[] nums = {3, -7, 6, 0, -2, 5};
        SumBetweenRange calculator = new SumBetweenRange(nums);

        System.out.println("=== Java Range Query Demonstration ===");
        System.out.println("Original array: " + Arrays.toString(nums));
        System.out.println("Prefix sums: " + Arrays.toString(calculator.prefixSum));

        // Test with PDF examples
        System.out.println("sum_range(0, 3) = " + calculator.sumRange(0, 3)); // 2
        System.out.println("sum_range(2, 4) = " + calculator.sumRange(2, 4)); // 4
        System.out.println("sum_range(2, 2) = " + calculator.sumRange(2, 2)); // 6
    }
}
```

**C++ Implementation with Optimal Performance:**

```cpp
#include <vector>
#include <iostream>

class SumBetweenRange {
private:
    std::vector<int> prefixSum;

public:
    /**
     * Constructs prefix sum array following the PDF algorithm.
     * Optimized for performance with memory pre-allocation.
     */
    explicit SumBetweenRange(const std::vector<int>& nums) {
        if (nums.empty()) return;

        prefixSum.reserve(nums.size());  // Optimize memory allocation
        prefixSum.push_back(nums[0]);

        // Build prefix sum array following PDF structure
        for (size_t i = 1; i < nums.size(); ++i) {
            prefixSum.push_back(prefixSum.back() + nums[i]);
        }
    }

    /**
     * Returns range sum in constant time using PDF formulas.
     * Implements the mathematical relationships exactly as derived.
     */
    int sumRange(int i, int j) const {
        if (i == 0) {
            // Special case when i == 0
            return prefixSum[j];
        } else {
            // General case when i > 0
            return prefixSum[j] - prefixSum[i - 1];
        }
    }

    /**
     * Provides access to prefix sum array for analysis.
     */
    const std::vector<int>& getPrefixSums() const {
        return prefixSum;
    }

    /**
     * Demonstrates range query capabilities with PDF examples.
     */
    static void demonstrateRangeQueries() {
        std::vector<int> nums = {3, -7, 6, 0, -2, 5};
        SumBetweenRange calculator(nums);

        std::cout << "=== C++ Range Query Demonstration ===" << std::endl;
        std::cout << "Original array: ";
        for (int val : nums) std::cout << val << " ";
        std::cout << std::endl;

        std::cout << "Prefix sums: ";
        for (int val : calculator.getPrefixSums()) std::cout << val << " ";
        std::cout << std::endl;

        // Test with exact PDF examples
        std::cout << "sum_range(0, 3) = " << calculator.sumRange(0, 3) << std::endl; // 2
        std::cout << "sum_range(2, 4) = " << calculator.sumRange(2, 4) << std::endl; // 4
        std::cout << "sum_range(2, 2) = " << calculator.sumRange(2, 2) << std::endl; // 6
    }
};
```

##### Index-Based Formula Derivation and Mathematical Proofs

The mathematical foundation underlying constant-time range queries deserves careful examination. Let me walk you through
the exact derivation process shown in your PDF material, which reveals why the formulas work and how they achieve
optimal efficiency.

The key insight lies in understanding what prefix sums represent mathematically. For any array `nums`, the prefix sum at
index `j` contains the sum of all elements from index `0` through index `j`. When we want to find the sum of a subrange
`[i, j]`, we can use this cumulative property to our advantage.

**Case 1: When i = 0** When the range starts at index 0, the sum equals `prefix_sum[j]` directly. This follows
immediately from the definition of prefix sums, since `prefix_sum[j]` already contains the sum from index 0 to j.

**Case 2: When i > 0** This case requires more sophisticated reasoning. Consider the relationship between different
prefix sums:

- `prefix_sum[j]` contains the sum of elements from index 0 to j
- `prefix_sum[i-1]` contains the sum of elements from index 0 to i-1

The sum of elements from index i to j equals the difference between these two prefix sums:
`prefix_sum[j] - prefix_sum[i-1]`. This works because subtracting `prefix_sum[i-1]` removes exactly the elements from
index 0 to i-1, leaving only the elements from index i to j.

Let me demonstrate this mathematical relationship using the exact visualization from your PDF:

```python
def demonstrate_mathematical_derivation():
    """
    Shows the mathematical derivation using the exact PDF example.
    Visualizes why the formula works through step-by-step analysis.
    """
    nums = [3, -7, 6, 0, -2, 5]
    prefix_sums = [3, -4, 2, 2, 0, 5]  # From PDF

    print("=== Mathematical Formula Derivation ===")
    print(f"nums = {nums}")
    print(f"prefix_sums = {prefix_sums}")

    # Demonstrate Case 2: sum_range(2, 4)
    i, j = 2, 4
    print(f"\nFinding sum_range({i}, {j}):")
    print(f"We want: nums[2] + nums[3] + nums[4] = {nums[2]} + {nums[3]} + {nums[4]} = {sum(nums[i:j+1])}")

    # Show how prefix sums help
    print(f"\nUsing prefix sums:")
    print(f"prefix_sum[{j}] = sum from index 0 to {j} = {prefix_sums[j]}")
    print(f"prefix_sum[{i-1}] = sum from index 0 to {i-1} = {prefix_sums[i-1]}")
    print(f"Difference = {prefix_sums[j]} - {prefix_sums[i-1]} = {prefix_sums[j] - prefix_sums[i-1]}")

    # Verify the mathematics
    expected_sum = sum(nums[i:j+1])
    calculated_sum = prefix_sums[j] - prefix_sums[i-1]
    print(f"\nVerification: {expected_sum} == {calculated_sum} ? {expected_sum == calculated_sum}")

demonstrate_mathematical_derivation()
```

##### Edge Case Analysis for Boundary Conditions

Robust implementation of range query systems requires careful consideration of edge cases and boundary conditions. The
PDF material touches on several critical scenarios that can cause implementation bugs if not properly handled.

**Edge Case 1: Single Element Ranges** When `i == j`, we're querying a range containing only one element. The formula
`prefix_sum[j] - prefix_sum[i-1]` still works correctly, but we must ensure proper handling when `i = 0`.

**Edge Case 2: Full Array Range** When querying the entire array (`i = 0, j = n-1`), the result should equal the last
prefix sum. This tests whether our Case 1 handling works correctly.

**Edge Case 3: Empty Input Arrays** Although not explicitly covered in the PDF, production implementations must handle
empty arrays gracefully to prevent runtime errors.

**Edge Case 4: Negative Numbers** The PDF example includes negative numbers (-7, -2), which tests whether our
mathematical formulas work correctly with negative values. This is particularly important because prefix sums can
decrease as well as increase.

Let me show you a comprehensive edge case analysis that extends the PDF's approach:

```python
class RobustSumBetweenRange:
    """
    Enhanced implementation that handles all edge cases while maintaining
    the exact algorithmic approach from the PDF.
    """

    def __init__(self, nums):
        """
        Constructs prefix sum array with comprehensive edge case handling.
        """
        if not nums:
            self.prefix_sum = []
            return

        # Build prefix sum array following PDF approach
        self.prefix_sum = [nums[0]]
        for i in range(1, len(nums)):
            self.prefix_sum.append(self.prefix_sum[-1] + nums[i])

    def sum_range(self, i, j):
        """
        Returns range sum with comprehensive edge case handling.
        """
        # Handle empty array case
        if not self.prefix_sum:
            raise ValueError("Cannot query range on empty array")

        # Validate indices
        if i < 0 or j >= len(self.prefix_sum) or i > j:
            raise ValueError(f"Invalid range [{i}, {j}] for array of length {len(self.prefix_sum)}")

        # Apply PDF formulas with proper edge case handling
        if i == 0:
            return self.prefix_sum[j]
        else:
            return self.prefix_sum[j] - self.prefix_sum[i - 1]

    def comprehensive_test(self):
        """
        Tests all edge cases to ensure robustness.
        """
        if not self.prefix_sum:
            print("Cannot test empty array")
            return

        print("=== Comprehensive Edge Case Testing ===")
        n = len(self.prefix_sum)

        # Test single element ranges
        print("Single element ranges:")
        for i in range(n):
            result = self.sum_range(i, i)
            print(f"  sum_range({i}, {i}) = {result}")

        # Test full array range
        if n > 0:
            full_range_result = self.sum_range(0, n - 1)
            print(f"Full array range sum_range(0, {n-1}) = {full_range_result}")

        # Test ranges starting at 0
        print("Ranges starting at 0:")
        for j in range(min(3, n)):
            result = self.sum_range(0, j)
            print(f"  sum_range(0, {j}) = {result}")

# Test with PDF example and edge cases
def demonstrate_edge_case_analysis():
    # Test with PDF example
    nums = [3, -7, 6, 0, -2, 5]
    calculator = RobustSumBetweenRange(nums)
    calculator.comprehensive_test()

    # Test with edge case: single element
    print("\n=== Single Element Array ===")
    single_calc = RobustSumBetweenRange([42])
    single_calc.comprehensive_test()

    # Test with edge case: all negative numbers
    print("\n=== All Negative Numbers ===")
    negative_calc = RobustSumBetweenRange([-1, -2, -3, -4])
    negative_calc.comprehensive_test()

demonstrate_edge_case_analysis()
```

##### Implementation Patterns and Space-Time Trade-offs

The prefix sum approach represents a classic example of the **space-time trade-off** in algorithm design. By investing
$O(n)$ space for preprocessing and $O(n)$ time for construction, we achieve $O(1)$ time complexity for each subsequent
range query. This trade-off becomes increasingly favorable as the number of queries increases.

**Space Complexity Analysis:**

- Preprocessing: $O(n)$ space for prefix sum array
- Per query: $O(1)$ additional space
- Total: $O(n)$ space complexity

**Time Complexity Analysis:**

- Preprocessing: $O(n)$ time for single pass construction
- Per query: $O(1)$ time for arithmetic operations
- Amortized: $O(1)$ per query after preprocessing

The PDF correctly identifies that this represents optimal performance for the range sum query problem, since any
solution must examine every input element at least once (either during preprocessing or during queries).

#### Subarray Analysis and Hash Map Integration

The exploration of subarray problems represents one of the most sophisticated applications of prefix sum techniques.
Your PDF material presents the "K-Sum Subarrays" problem, which asks us to find the number of subarrays that sum to a
target value k. This problem beautifully demonstrates how prefix sums can be combined with hash map data structures to
achieve remarkable algorithmic optimizations.

##### K-Sum Subarray Detection Through Complementary Search

Let me walk you through the exact problem and solution approach presented in your PDF material. The problem asks us to
find the number of subarrays in an array that sum to a specific target k. The PDF provides a concrete example with
`nums = [1, 2, -1, 1, 2]` and `k = 3`, where the answer is 3 subarrays.

The naive brute force approach would examine all possible subarrays, requiring $O(n^3)$ time complexity (two nested
loops to generate subarrays and one loop to compute their sums). Your PDF shows how prefix sums can improve this to
$O(n^2)$, and then demonstrates the elegant hash map optimization that achieves $O(n)$ time complexity.

Let me trace through the exact solution development shown in your PDF material:

```python
def k_sum_subarrays_optimized(nums, k):
    """
    Optimized solution exactly as presented in the PDF.
    Uses hash map with prefix sums for O(n) time complexity.
    """
    count = 0
    # Initialize the map with 0 to handle subarrays that sum to 'k'
    # from the start of the array
    prefix_sum_map = {0: 1}
    curr_prefix_sum = 0

    for num in nums:
        # Update the running prefix sum by adding the current number
        curr_prefix_sum += num

        # If a subarray with sum 'k' exists, increment 'count' by the
        # number of times it has been found
        if curr_prefix_sum - k in prefix_sum_map:
            count += prefix_sum_map[curr_prefix_sum - k]

        # Update the frequency of 'curr_prefix_sum' in the hash map
        freq = prefix_sum_map.get(curr_prefix_sum, 0)
        prefix_sum_map[curr_prefix_sum] = freq + 1

    return count

# Demonstrate with the exact PDF example
def demonstrate_k_sum_algorithm():
    """
    Walks through the PDF example step by step to show how the algorithm works.
    """
    nums = [1, 2, -1, 1, 2]
    k = 3

    print("=== K-Sum Subarrays Algorithm Demonstration ===")
    print(f"Input: nums = {nums}, k = {k}")

    # Trace through the algorithm manually
    count = 0
    prefix_sum_map = {0: 1}
    curr_prefix_sum = 0

    print("\nStep-by-step execution:")
    for i, num in enumerate(nums):
        curr_prefix_sum += num
        complement = curr_prefix_sum - k

        print(f"\nStep {i+1}: Processing nums[{i}] = {num}")
        print(f"  curr_prefix_sum = {curr_prefix_sum}")
        print(f"  Looking for complement: {curr_prefix_sum} - {k} = {complement}")

        if complement in prefix_sum_map:
            found_count = prefix_sum_map[complement]
            count += found_count
            print(f"  Found {found_count} occurrence(s) of {complement}")
            print(f"  count += {found_count}, new count = {count}")
        else:
            print(f"  Complement {complement} not found in map")

        # Update frequency
        freq = prefix_sum_map.get(curr_prefix_sum, 0)
        prefix_sum_map[curr_prefix_sum] = freq + 1
        print(f"  Updated map: {prefix_sum_map}")

    print(f"\nFinal result: {count} subarrays sum to {k}")

    # Verify with the optimized function
    result = k_sum_subarrays_optimized(nums, k)
    print(f"Verification: {result}")

demonstrate_k_sum_algorithm()
```

**Java Implementation Following PDF Structure:**

```java
import java.util.*;

public class KSumSubarrays {

    /**
     * Finds number of subarrays that sum to k using the exact algorithm from PDF.
     * Demonstrates the progression from O(n²) to O(n) optimization.
     */
    public static int kSumSubarraysOptimized(int[] nums, int k) {
        int count = 0;
        // Initialize the map with 0 to handle subarrays that sum to 'k'
        // from the start of the array
        Map<Integer, Integer> prefixSumMap = new HashMap<>();
        prefixSumMap.put(0, 1);
        int currPrefixSum = 0;

        for (int num : nums) {
            // Update the running prefix sum by adding the current number
            currPrefixSum += num;

            // If a subarray with sum 'k' exists, increment 'count' by the
            // number of times it has been found
            if (prefixSumMap.containsKey(currPrefixSum - k)) {
                count += prefixSumMap.get(currPrefixSum - k);
            }

            // Update the frequency of 'currPrefixSum' in the hash map
            prefixSumMap.put(currPrefixSum, prefixSumMap.getOrDefault(currPrefixSum, 0) + 1);
        }

        return count;
    }

    /**
     * Demonstrates the algorithm progression showing the O(n²) approach first.
     * This follows the PDF's pedagogical approach of showing the optimization path.
     */
    public static int kSumSubarraysNaiveWithPrefixSum(int[] nums, int k) {
        int n = nums.length;
        int count = 0;

        // Populate the prefix sum array, setting its first element to 0
        int[] prefixSum = new int[n + 1];
        prefixSum[0] = 0;
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }

        // Loop through all valid pairs of prefix sum values to find all
        // subarrays that sum to 'k'
        for (int j = 1; j <= n; j++) {
            for (int i = 1; i <= j; i++) {
                if (prefixSum[j] - prefixSum[i - 1] == k) {
                    count++;
                }
            }
        }

        return count;
    }

    /**
     * Comprehensive demonstration showing both approaches and their complexity.
     */
    public static void demonstrateKSumAlgorithms() {
        // Use exact example from PDF
        int[] nums = {1, 2, -1, 1, 2};
        int k = 3;

        System.out.println("=== K-Sum Subarrays Demonstration ===");
        System.out.println("Input: nums = " + Arrays.toString(nums) + ", k = " + k);

        // Test O(n²) approach
        long startTime = System.nanoTime();
        int result1 = kSumSubarraysNaiveWithPrefixSum(nums, k);
        long time1 = System.nanoTime() - startTime;

        // Test O(n) approach
        startTime = System.nanoTime();
        int result2 = kSumSubarraysOptimized(nums, k);
        long time2 = System.nanoTime() - startTime;

        System.out.println("O(n²) approach result: " + result1 + " (Time: " + time1 + " ns)");
        System.out.println("O(n) approach result: " + result2 + " (Time: " + time2 + " ns)");
        System.out.println("Results match: " + (result1 == result2));

        // Show the detailed step-by-step for the optimized approach
        demonstrateStepByStep(nums, k);
    }

    /**
     * Shows the step-by-step execution following the PDF's explanation.
     */
    private static void demonstrateStepByStep(int[] nums, int k) {
        System.out.println("\n=== Step-by-step execution (O(n) approach) ===");

        int count = 0;
        Map<Integer, Integer> prefixSumMap = new HashMap<>();
        prefixSumMap.put(0, 1);
        int currPrefixSum = 0;

        System.out.println("Initial state: prefixSumMap = " + prefixSumMap);

        for (int i = 0; i < nums.length; i++) {
            currPrefixSum += nums[i];
            int complement = currPrefixSum - k;

            System.out.printf("\nStep %d: nums[%d] = %d\n", i + 1, i, nums[i]);
            System.out.printf("  currPrefixSum = %d\n", currPrefixSum);
            System.out.printf("  Looking for complement: %d - %d = %d\n", currPrefixSum, k, complement);

            if (prefixSumMap.containsKey(complement)) {
                int foundCount = prefixSumMap.get(complement);
                count += foundCount;
                System.out.printf("  Found %d occurrence(s) of %d\n", foundCount, complement);
                System.out.printf("  count += %d, new count = %d\n", foundCount, count);
            } else {
                System.out.printf("  Complement %d not found\n", complement);
            }

            prefixSumMap.put(currPrefixSum, prefixSumMap.getOrDefault(currPrefixSum, 0) + 1);
            System.out.println("  Updated map: " + prefixSumMap);
        }

        System.out.println("\nFinal result: " + count + " subarrays sum to " + k);
    }
}
```

**C++ Implementation with Performance Analysis:**

```cpp
#include <vector>
#include <unordered_map>
#include <iostream>
#include <chrono>

class KSumSubarrays {
public:
    /**
     * Optimized O(n) solution using hash map with prefix sums.
     * Follows the exact algorithm structure from the PDF.
     */
    static int kSumSubarraysOptimized(const std::vector<int>& nums, int k) {
        int count = 0;
        // Initialize the map with 0 to handle subarrays that sum to 'k'
        // from the start of the array
        std::unordered_map<int, int> prefixSumMap;
        prefixSumMap[0] = 1;
        int currPrefixSum = 0;

        for (int num : nums) {
            // Update the running prefix sum by adding the current number
            currPrefixSum += num;

            // If a subarray with sum 'k' exists, increment 'count' by the
            // number of times it has been found
            auto it = prefixSumMap.find(currPrefixSum - k);
            if (it != prefixSumMap.end()) {
                count += it->second;
            }

            // Update the frequency of 'currPrefixSum' in the hash map
            prefixSumMap[currPrefixSum]++;
        }

        return count;
    }

    /**
     * O(n²) solution using prefix sums (intermediate optimization from PDF).
     */
    static int kSumSubarraysNaiveWithPrefixSum(const std::vector<int>& nums, int k) {
        int n = nums.size();
        int count = 0;

        // Build prefix sum array with 0 prepended as shown in PDF
        std::vector<int> prefixSum(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }

        // Check all possible subarrays using prefix sum differences
        for (int j = 1; j <= n; j++) {
            for (int i = 1; i <= j; i++) {
                if (prefixSum[j] - prefixSum[i - 1] == k) {
                    count++;
                }
            }
        }

        return count;
    }

    /**
     * Demonstrates the algorithm with comprehensive performance analysis.
     */
    static void demonstrateWithPerformanceAnalysis() {
        // Use the exact example from PDF
        std::vector<int> nums = {1, 2, -1, 1, 2};
        int k = 3;

        std::cout << "=== K-Sum Subarrays Performance Analysis ===" << std::endl;
        std::cout << "Input: nums = ";
        for (int num : nums) std::cout << num << " ";
        std::cout << ", k = " << k << std::endl;

        // Measure O(n²) approach
        auto start = std::chrono::high_resolution_clock::now();
        int result1 = kSumSubarraysNaiveWithPrefixSum(nums, k);
        auto end = std::chrono::high_resolution_clock::now();
        auto duration1 = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);

        // Measure O(n) approach
        start = std::chrono::high_resolution_clock::now();
        int result2 = kSumSubarraysOptimized(nums, k);
        end = std::chrono::high_resolution_clock::now();
        auto duration2 = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);

        std::cout << "O(n²) approach: " << result1 << " (" << duration1.count() << " ns)" << std::endl;
        std::cout << "O(n) approach: " << result2 << " (" << duration2.count() << " ns)" << std::endl;
        std::cout << "Results match: " << (result1 == result2 ? "Yes" : "No") << std::endl;

        if (duration1.count() > 0) {
            double speedup = static_cast<double>(duration1.count()) / duration2.count();
            std::cout << "Speedup: " << speedup << "x" << std::endl;
        }

        // Demonstrate step-by-step execution
        demonstrateStepByStep(nums, k);
    }

private:
    static void demonstrateStepByStep(const std::vector<int>& nums, int k) {
        std::cout << "\n=== Step-by-step execution ===" << std::endl;

        int count = 0;
        std::unordered_map<int, int> prefixSumMap;
        prefixSumMap[0] = 1;
        int currPrefixSum = 0;

        std::cout << "Initial: prefixSumMap[0] = 1" << std::endl;

        for (size_t i = 0; i < nums.size(); i++) {
            currPrefixSum += nums[i];
            int complement = currPrefixSum - k;

            std::cout << "\nStep " << (i + 1) << ": nums[" << i << "] = " << nums[i] << std::endl;
            std::cout << "  currPrefixSum = " << currPrefixSum << std::endl;
            std::cout << "  complement = " << currPrefixSum << " - " << k << " = " << complement << std::endl;

            auto it = prefixSumMap.find(complement);
            if (it != prefixSumMap.end()) {
                count += it->second;
                std::cout << "  Found " << it->second << " occurrence(s) of " << complement << std::endl;
                std::cout << "  count += " << it->second << ", new count = " << count << std::endl;
            } else {
                std::cout << "  Complement " << complement << " not found" << std::endl;
            }

            prefixSumMap[currPrefixSum]++;
            std::cout << "  Updated prefixSumMap[" << currPrefixSum << "] = " << prefixSumMap[currPrefixSum] << std::endl;
        }

        std::cout << "\nFinal result: " << count << " subarrays sum to " << k << std::endl;
    }
};
```

##### Hash Map Frequency Tracking for Multiple Occurrences

The brilliant insight in the PDF's optimization lies in recognizing that we need to track not just which prefix sums
we've seen, but how many times we've seen each one. This frequency tracking is crucial because the same prefix sum can
appear multiple times, and each occurrence represents a potential starting point for a subarray that sums to k.

The PDF's step-by-step walkthrough shows exactly why this frequency tracking matters. When we process the array
`[1, 2, -1, 1, 2]` with `k = 3`, we encounter situations where the same prefix sum appears multiple times, and each
appearance contributes to our final count.

##### Optimization from O(n²) to O(n) Time Complexity

The transformation from O(n²) to O(n) represents one of the most elegant optimizations in algorithmic design. Your PDF
shows this progression beautifully:

1. **Naive O(n³)**: Check all subarrays and compute their sums
2. **Improved O(n²)**: Use prefix sums to compute subarray sums in constant time
3. **Optimal O(n)**: Use hash map to avoid the inner loop entirely

The key insight for the final optimization is recognizing that instead of checking all possible starting positions for
each ending position, we can use the mathematical relationship: if `prefix_sum[j] - prefix_sum[i-1] = k`, then we need
`prefix_sum[i-1] = prefix_sum[j] - k`. By storing previous prefix sums in a hash map, we can check this condition in
constant time.

##### Mathematical Foundation of Prefix Sum Complement Theory

The mathematical foundation underlying this optimization rests on what we might call the **Prefix Sum Complement
Theory**. For any target sum k and current prefix sum s, we need to find how many previous prefix sums equal `s - k`.
This transforms the subarray sum problem into a two-sum variant that can be solved efficiently with hash maps.

The mathematical relationship can be expressed as: for a subarray from index i to j to sum to k, we need
`prefix_sum[j] - prefix_sum[i-1] = k`, which rearranges to `prefix_sum[i-1] = prefix_sum[j] - k`. The hash map stores
the frequency of each `prefix_sum[i-1]` value we've encountered, allowing constant-time lookup of how many valid
starting positions exist for the current ending position.

#### Prefix Product Algorithms and Division-Free Computation

The final section of your PDF material introduces the "Product Array Without Current Element" problem, which
demonstrates how the prefix sum concept extends to multiplicative operations. This problem asks us to create an array
where each element equals the product of all other elements in the original array, specifically excluding the element at
the current index.

##### Left and Right Product Array Construction Methods

Following your PDF's approach, the problem can be elegantly solved by recognizing that the product of all elements
except the current one equals the product of all elements to the left multiplied by the product of all elements to the
right. This insight leads to the **two-array approach** that your PDF demonstrates.

Let me implement this exactly as shown in your material:

```python
def product_array_without_current_element(nums):
    """
    Creates product array using the two-array approach from the PDF.
    Demonstrates left and right product array construction.
    """
    n = len(nums)

    # Create left products array
    left_products = [1] * n
    left_products[0] = 1  # No elements to the left of first element
    for i in range(1, n):
        left_products[i] = left_products[i - 1] * nums[i - 1]

    # Create right products array
    right_products = [1] * n
    right_products[n - 1] = 1  # No elements to the right of last element
    for i in range(n - 2, -1, -1):
        right_products[i] = right_products[i + 1] * nums[i + 1]

    # Combine left and right products
    result = [1] * n
    for i in range(n):
        result[i] = left_products[i] * right_products[i]

    return result

# Demonstrate with PDF example
def demonstrate_product_arrays():
    """
    Uses the exact example from the PDF to show the algorithm.
    """
    nums = [2, 3, 1, 4, 5]

    print("=== Product Array Construction Demonstration ===")
    print(f"Input: {nums}")

    # Show step-by-step construction
    n = len(nums)
    left_products = [1] * n
    left_products[0] = 1

    print(f"\nLeft products construction:")
    print(f"left_products[0] = 1 (no elements to the left)")
    for i in range(1, n):
        left_products[i] = left_products[i - 1] * nums[i - 1]
        print(f"left_products[{i}] = {left_products[i - 1]} * {nums[i - 1]} = {left_products[i]}")

    right_products = [1] * n
    right_products[n - 1] = 1

    print(f"\nRight products construction:")
    print(f"right_products[{n-1}] = 1 (no elements to the right)")
    for i in range(n - 2, -1, -1):
        right_products[i] = right_products[i + 1] * nums[i + 1]
        print(f"right_products[{i}] = {right_products[i + 1]} * {nums[i + 1]} = {right_products[i]}")

    # Final result
    result = [left_products[i] * right_products[i] for i in range(n)]

    print(f"\nFinal calculation:")
    for i in range(n):
        print(f"result[{i}] = {left_products[i]} * {right_products[i]} = {result[i]}")

    print(f"\nFinal result: {result}")
    return result

demonstrate_product_arrays()
```

##### Space Optimization Through In-Place Computation

Your PDF demonstrates the elegant space optimization where we eliminate the need for separate left and right product
arrays by using the output array itself for intermediate storage. This represents the **two-pass in-place optimization**
that reduces space complexity from O(n) to O(1) (not counting the output array).

Following the exact approach from your PDF:

```python
def product_array_without_current_element_optimized(nums):
    """
    Space-optimized version following the PDF's two-pass approach.
    Uses the output array for intermediate storage.
    """
    n = len(nums)
    res = [1] * n

    # First pass: populate with left products
    for i in range(1, n):
        res[i] = res[i - 1] * nums[i - 1]

    # Second pass: multiply by right products from right to left
    right_product = 1
    for i in range(n - 1, -1, -1):
        res[i] *= right_product
        right_product *= nums[i]

    return res

# Demonstrate the space optimization
def demonstrate_space_optimization():
    """
    Shows the step-by-step space-optimized algorithm from the PDF.
    """
    nums = [2, 3, 1, 4, 5]
    n = len(nums)

    print("=== Space-Optimized Algorithm Demonstration ===")
    print(f"Input: {nums}")

    # Initialize result array
    res = [1] * n
    print(f"Initial res: {res}")

    # First pass: left products
    print(f"\nFirst pass (left products):")
    for i in range(1, n):
        res[i] = res[i - 1] * nums[i - 1]
        print(f"res[{i}] = res[{i-1}] * nums[{i-1}] = {res[i-1]} * {nums[i-1]} = {res[i]}")

    print(f"After first pass: {res}")

    # Second pass: multiply by right products
    print(f"\nSecond pass (multiply by right products):")
    right_product = 1
    for i in range(n - 1, -1, -1):
        print(f"Step {n-i}: res[{i}] = {res[i]} * {right_product} = {res[i] * right_product}")
        res[i] *= right_product
        right_product *= nums[i]
        print(f"  Updated res[{i}] = {res[i]}, right_product = {right_product}")

    print(f"\nFinal result: {res}")
    return res

demonstrate_space_optimization()
```

**Java Implementation with Complete PDF Approach:**

```java
public class ProductArrayWithoutCurrentElement {

    /**
     * Two-array approach exactly as shown in the PDF.
     * Demonstrates the conceptual foundation before optimization.
     */
    public static int[] productArrayTwoArrays(int[] nums) {
        int n = nums.length;

        // Create left products array
        int[] leftProducts = new int[n];
        leftProducts[0] = 1;
        for (int i = 1; i < n; i++) {
            leftProducts[i] = leftProducts[i - 1] * nums[i - 1];
        }

        // Create right products array
        int[] rightProducts = new int[n];
        rightProducts[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            rightProducts[i] = rightProducts[i + 1] * nums[i + 1];
        }

        // Combine results
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            result[i] = leftProducts[i] * rightProducts[i];
        }

        return result;
    }

    /**
     * Space-optimized version following the PDF's two-pass approach.
     */
    public static int[] productArrayOptimized(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];

        // Populate the output with the running left product
        res[0] = 1;
        for (int i = 1; i < n; i++) {
            res[i] = res[i - 1] * nums[i - 1];
        }

        // Multiply the output with the running right product, from right to left
        int rightProduct = 1;
        for (int i = n - 1; i >= 0; i--) {
            res[i] *= rightProduct;
            rightProduct *= nums[i];
        }

        return res;
    }

    /**
     * Demonstrates both approaches with the PDF example.
     */
    public static void demonstrateProductArrayAlgorithms() {
        int[] nums = {2, 3, 1, 4, 5};

        System.out.println("=== Product Array Algorithm Demonstration ===");
        System.out.println("Input: " + Arrays.toString(nums));

        // Test two-array approach
        int[] result1 = productArrayTwoArrays(nums);
        System.out.println("Two-array approach: " + Arrays.toString(result1));

        // Test optimized approach
        int[] result2 = productArrayOptimized(nums);
        System.out.println("Optimized approach: " + Arrays.toString(result2));

        // Verify results match
        System.out.println("Results match: " + Arrays.equals(result1, result2));

        // Show step-by-step for optimized version
        demonstrateOptimizedSteps(nums);
    }

    private static void demonstrateOptimizedSteps(int[] nums) {
        System.out.println("\n=== Step-by-step Optimized Algorithm ===");
        int n = nums.length;
        int[] res = new int[n];

        // First pass
        System.out.println("First pass (left products):");
        res[0] = 1;
        System.out.println("res[0] = 1");
        for (int i = 1; i < n; i++) {
            res[i] = res[i - 1] * nums[i - 1];
            System.out.printf("res[%d] = %d * %d = %d%n", i, res[i-1], nums[i-1], res[i]);
        }
        System.out.println("After first pass: " + Arrays.toString(res));

        // Second pass
        System.out.println("\nSecond pass (multiply by right products):");
        int rightProduct = 1;
        for (int i = n - 1; i >= 0; i--) {
            System.out.printf("res[%d] *= %d → %d * %d = %d%n",
                            i, rightProduct, res[i], rightProduct, res[i] * rightProduct);
            res[i] *= rightProduct;
            rightProduct *= nums[i];
            System.out.printf("rightProduct = %d * %d = %d%n", rightProduct/nums[i], nums[i], rightProduct);
        }
        System.out.println("Final result: " + Arrays.toString(res));
    }
}
```

##### Avoiding Division Operations Through Multiplicative Decomposition

The elegance of the product array problem lies in avoiding division operations entirely. Your PDF mentions this as a
potential follow-up question: "what if we can't use division?" The two-pass approach provides a division-free solution
that works even when the array contains zeros (where division would fail).

The **multiplicative decomposition principle** breaks each result element into the product of two independent
components: left products and right products. This decomposition ensures that we never need to divide the total product
by the current element, which could cause issues with integer division, floating-point precision, or zero values.

##### Two-Pass Algorithm Design and Implementation Analysis

The two-pass algorithm represents optimal performance for the product array problem:

**Time Complexity**: O(n) for each pass, giving O(n) total time complexity **Space Complexity**: O(1) extra space (not
counting the output array)

The algorithm achieves optimality because:

1. Every input element must be examined at least once
2. Every output element must be computed
3. The two-pass approach minimizes both time and space requirements
